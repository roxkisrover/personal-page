{
  "version": 3,
  "sources": ["../preact/debug/src/check-props.js", "../preact/debug/src/component-stack.js", "../preact/debug/src/debug.js", "../preact/debug/src/constants.js", "../preact/debug/src/util.js"],
  "sourcesContent": ["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\r\n\r\nlet loggedTypeFailures = {};\r\n\r\n/**\r\n * Reset the history of which prop type warnings have been logged.\r\n */\r\nexport function resetPropWarnings() {\r\n\tloggedTypeFailures = {};\r\n}\r\n\r\n/**\r\n * Assert that the values match with the type specs.\r\n * Error messages are memorized and will only be shown once.\r\n *\r\n * Adapted from https://github.com/facebook/prop-types/blob/master/checkPropTypes.js\r\n *\r\n * @param {object} typeSpecs Map of name to a ReactPropType\r\n * @param {object} values Runtime values that need to be type-checked\r\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\r\n * @param {string} componentName Name of the component for error messages.\r\n * @param {?Function} getStack Returns the component stack.\r\n */\r\nexport function checkPropTypes(\r\n\ttypeSpecs,\r\n\tvalues,\r\n\tlocation,\r\n\tcomponentName,\r\n\tgetStack\r\n) {\r\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\r\n\t\tlet error;\r\n\t\ttry {\r\n\t\t\terror = typeSpecs[typeSpecName](\r\n\t\t\t\tvalues,\r\n\t\t\t\ttypeSpecName,\r\n\t\t\t\tcomponentName,\r\n\t\t\t\tlocation,\r\n\t\t\t\tnull,\r\n\t\t\t\tReactPropTypesSecret\r\n\t\t\t);\r\n\t\t} catch (e) {\r\n\t\t\terror = e;\r\n\t\t}\r\n\t\tif (error && !(error.message in loggedTypeFailures)) {\r\n\t\t\tloggedTypeFailures[error.message] = true;\r\n\t\t\tconsole.error(\r\n\t\t\t\t`Failed ${location} type: ${error.message}${(getStack &&\r\n\t\t\t\t\t`\\n${getStack()}`) ||\r\n\t\t\t\t\t''}`\r\n\t\t\t);\r\n\t\t}\r\n\t});\r\n}\r\n", "import { options, Fragment } from 'preact';\r\n\r\n/**\r\n * Get human readable name of the component/dom node\r\n * @param {import('./internal').VNode} vnode\r\n * @param {import('./internal').VNode} vnode\r\n * @returns {string}\r\n */\r\nexport function getDisplayName(vnode) {\r\n\tif (vnode.type === Fragment) {\r\n\t\treturn 'Fragment';\r\n\t} else if (typeof vnode.type == 'function') {\r\n\t\treturn vnode.type.displayName || vnode.type.name;\r\n\t} else if (typeof vnode.type == 'string') {\r\n\t\treturn vnode.type;\r\n\t}\r\n\r\n\treturn '#text';\r\n}\r\n\r\n/**\r\n * Used to keep track of the currently rendered `vnode` and print it\r\n * in debug messages.\r\n */\r\nlet renderStack = [];\r\n\r\n/**\r\n * Keep track of the current owners. An owner describes a component\r\n * which was responsible to render a specific `vnode`. This exclude\r\n * children that are passed via `props.children`, because they belong\r\n * to the parent owner.\r\n *\r\n * ```jsx\r\n * const Foo = props => <div>{props.children}</div> // div's owner is Foo\r\n * const Bar = props => {\r\n *   return (\r\n *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * Note: A `vnode` may be hoisted to the root scope due to compiler\r\n * optimiztions. In these cases the `_owner` will be different.\r\n */\r\nlet ownerStack = [];\r\n\r\n/**\r\n * Get the currently rendered `vnode`\r\n * @returns {import('./internal').VNode | null}\r\n */\r\nexport function getCurrentVNode() {\r\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\r\n}\r\n\r\n/**\r\n * If the user doesn't have `@babel/plugin-transform-react-jsx-source`\r\n * somewhere in his tool chain we can't print the filename and source\r\n * location of a component. In that case we just omit that, but we'll\r\n * print a helpful message to the console, notifying the user of it.\r\n */\r\nlet hasBabelPlugin = false;\r\n\r\n/**\r\n * Check if a `vnode` is a possible owner.\r\n * @param {import('./internal').VNode} vnode\r\n */\r\nfunction isPossibleOwner(vnode) {\r\n\treturn typeof vnode.type == 'function' && vnode.type != Fragment;\r\n}\r\n\r\n/**\r\n * Return the component stack that was captured up to this point.\r\n * @param {import('./internal').VNode} vnode\r\n * @returns {string}\r\n */\r\nexport function getOwnerStack(vnode) {\r\n\tconst stack = [vnode];\r\n\tlet next = vnode;\r\n\twhile (next._owner != null) {\r\n\t\tstack.push(next._owner);\r\n\t\tnext = next._owner;\r\n\t}\r\n\r\n\treturn stack.reduce((acc, owner) => {\r\n\t\tacc += `  in ${getDisplayName(owner)}`;\r\n\r\n\t\tconst source = owner.__source;\r\n\t\tif (source) {\r\n\t\t\tacc += ` (at ${source.fileName}:${source.lineNumber})`;\r\n\t\t} else if (!hasBabelPlugin) {\r\n\t\t\thasBabelPlugin = true;\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn (acc += '\\n');\r\n\t}, '');\r\n}\r\n\r\n/**\r\n * Setup code to capture the component trace while rendering. Note that\r\n * we cannot simply traverse `vnode._parent` upwards, because we have some\r\n * debug messages for `this.setState` where the `vnode` is `undefined`.\r\n */\r\nexport function setupComponentStack() {\r\n\tlet oldDiff = options._diff;\r\n\tlet oldDiffed = options.diffed;\r\n\tlet oldRoot = options._root;\r\n\tlet oldVNode = options.vnode;\r\n\tlet oldRender = options._render;\r\n\r\n\toptions.diffed = vnode => {\r\n\t\tif (isPossibleOwner(vnode)) {\r\n\t\t\townerStack.pop();\r\n\t\t}\r\n\t\trenderStack.pop();\r\n\t\tif (oldDiffed) oldDiffed(vnode);\r\n\t};\r\n\r\n\toptions._diff = vnode => {\r\n\t\tif (isPossibleOwner(vnode)) {\r\n\t\t\trenderStack.push(vnode);\r\n\t\t}\r\n\t\tif (oldDiff) oldDiff(vnode);\r\n\t};\r\n\r\n\toptions._root = (vnode, parent) => {\r\n\t\townerStack = [];\r\n\t\tif (oldRoot) oldRoot(vnode, parent);\r\n\t};\r\n\r\n\toptions.vnode = vnode => {\r\n\t\tvnode._owner =\r\n\t\t\townerStack.length > 0 ? ownerStack[ownerStack.length - 1] : null;\r\n\t\tif (oldVNode) oldVNode(vnode);\r\n\t};\r\n\r\n\toptions._render = vnode => {\r\n\t\tif (isPossibleOwner(vnode)) {\r\n\t\t\townerStack.push(vnode);\r\n\t\t}\r\n\r\n\t\tif (oldRender) oldRender(vnode);\r\n\t};\r\n}\r\n", "import { checkPropTypes } from './check-props';\r\nimport { options, Component } from 'preact';\r\nimport {\r\n\tELEMENT_NODE,\r\n\tDOCUMENT_NODE,\r\n\tDOCUMENT_FRAGMENT_NODE\r\n} from './constants';\r\nimport {\r\n\tgetOwnerStack,\r\n\tsetupComponentStack,\r\n\tgetCurrentVNode,\r\n\tgetDisplayName\r\n} from './component-stack';\r\nimport { assign } from './util';\r\n\r\nconst isWeakMapSupported = typeof WeakMap == 'function';\r\n\r\nfunction getClosestDomNodeParent(parent) {\r\n\tif (!parent) return {};\r\n\tif (typeof parent.type == 'function') {\r\n\t\treturn getClosestDomNodeParent(parent._parent);\r\n\t}\r\n\treturn parent;\r\n}\r\n\r\nexport function initDebug() {\r\n\tsetupComponentStack();\r\n\r\n\tlet hooksAllowed = false;\r\n\r\n\t/* eslint-disable no-console */\r\n\tlet oldBeforeDiff = options._diff;\r\n\tlet oldDiffed = options.diffed;\r\n\tlet oldVnode = options.vnode;\r\n\tlet oldCatchError = options._catchError;\r\n\tlet oldRoot = options._root;\r\n\tlet oldHook = options._hook;\r\n\tconst warnedComponents = !isWeakMapSupported\r\n\t\t? null\r\n\t\t: {\r\n\t\t\t\tuseEffect: new WeakMap(),\r\n\t\t\t\tuseLayoutEffect: new WeakMap(),\r\n\t\t\t\tlazyPropTypes: new WeakMap()\r\n\t\t  };\r\n\tconst deprecations = [];\r\n\r\n\toptions._catchError = (error, vnode, oldVNode) => {\r\n\t\tlet component = vnode && vnode._component;\r\n\t\tif (component && typeof error.then == 'function') {\r\n\t\t\tconst promise = error;\r\n\t\t\terror = new Error(\r\n\t\t\t\t`Missing Suspense. The throwing component was: ${getDisplayName(vnode)}`\r\n\t\t\t);\r\n\r\n\t\t\tlet parent = vnode;\r\n\t\t\tfor (; parent; parent = parent._parent) {\r\n\t\t\t\tif (parent._component && parent._component._childDidSuspend) {\r\n\t\t\t\t\terror = promise;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// We haven't recovered and we know at this point that there is no\r\n\t\t\t// Suspense component higher up in the tree\r\n\t\t\tif (error instanceof Error) {\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\toldCatchError(error, vnode, oldVNode);\r\n\r\n\t\t\t// when an error was handled by an ErrorBoundary we will nontheless emit an error\r\n\t\t\t// event on the window object. This is to make up for react compatibility in dev mode\r\n\t\t\t// and thus make the Next.js dev overlay work.\r\n\t\t\tif (typeof error.then != 'function') {\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tthrow error;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t};\r\n\r\n\toptions._root = (vnode, parentNode) => {\r\n\t\tif (!parentNode) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Undefined parent passed to render(), this is the second argument.\\n' +\r\n\t\t\t\t\t'Check if the element is available in the DOM/has the correct id.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tlet isValid;\r\n\t\tswitch (parentNode.nodeType) {\r\n\t\t\tcase ELEMENT_NODE:\r\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\r\n\t\t\tcase DOCUMENT_NODE:\r\n\t\t\t\tisValid = true;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tisValid = false;\r\n\t\t}\r\n\r\n\t\tif (!isValid) {\r\n\t\t\tlet componentName = getDisplayName(vnode);\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Expected a valid HTML node as a second argument to render.\tReceived ${parentNode} instead: render(<${componentName} />, ${parentNode});`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (oldRoot) oldRoot(vnode, parentNode);\r\n\t};\r\n\r\n\toptions._diff = vnode => {\r\n\t\tlet { type, _parent: parent } = vnode;\r\n\t\tlet parentVNode = getClosestDomNodeParent(parent);\r\n\r\n\t\thooksAllowed = true;\r\n\r\n\t\tif (type === undefined) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Undefined component passed to createElement()\\n\\n' +\r\n\t\t\t\t\t'You likely forgot to export your component or might have mixed up default and named imports' +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t} else if (type != null && typeof type == 'object') {\r\n\t\t\tif (type._children !== undefined && type._dom !== undefined) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Invalid type passed to createElement(): ${type}\\n\\n` +\r\n\t\t\t\t\t\t'Did you accidentally pass a JSX literal as JSX twice?\\n\\n' +\r\n\t\t\t\t\t\t`  let My${getDisplayName(vnode)} = ${serializeVNode(type)};\\n` +\r\n\t\t\t\t\t\t`  let vnode = <My${getDisplayName(vnode)} />;\\n\\n` +\r\n\t\t\t\t\t\t'This usually happens when you export a JSX literal and not the component.' +\r\n\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Invalid type passed to createElement(): ' +\r\n\t\t\t\t\t(Array.isArray(type) ? 'array' : type)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\t(type === 'thead' || type === 'tfoot' || type === 'tbody') &&\r\n\t\t\tparentVNode.type !== 'table'\r\n\t\t) {\r\n\t\t\tconsole.error(\r\n\t\t\t\t'Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t} else if (\r\n\t\t\ttype === 'tr' &&\r\n\t\t\tparentVNode.type !== 'thead' &&\r\n\t\t\tparentVNode.type !== 'tfoot' &&\r\n\t\t\tparentVNode.type !== 'tbody' &&\r\n\t\t\tparentVNode.type !== 'table'\r\n\t\t) {\r\n\t\t\tconsole.error(\r\n\t\t\t\t'Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent.' +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t} else if (type === 'td' && parentVNode.type !== 'tr') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t'Improper nesting of table. Your <td> should have a <tr> parent.' +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t} else if (type === 'th' && parentVNode.type !== 'tr') {\r\n\t\t\tconsole.error(\r\n\t\t\t\t'Improper nesting of table. Your <th> should have a <tr>.' +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tvnode.ref !== undefined &&\r\n\t\t\ttypeof vnode.ref != 'function' &&\r\n\t\t\ttypeof vnode.ref != 'object' &&\r\n\t\t\t!('$$typeof' in vnode) // allow string refs when preact-compat is installed\r\n\t\t) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\r\n\t\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\r\n\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (typeof vnode.type == 'string') {\r\n\t\t\tfor (const key in vnode.props) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tkey[0] === 'o' &&\r\n\t\t\t\t\tkey[1] === 'n' &&\r\n\t\t\t\t\ttypeof vnode.props[key] != 'function' &&\r\n\t\t\t\t\tvnode.props[key] != null\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\r\n\t\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\r\n\t\t\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check prop-types if available\r\n\t\tif (typeof vnode.type == 'function' && vnode.type.propTypes) {\r\n\t\t\tif (\r\n\t\t\t\tvnode.type.displayName === 'Lazy' &&\r\n\t\t\t\twarnedComponents &&\r\n\t\t\t\t!warnedComponents.lazyPropTypes.has(vnode.type)\r\n\t\t\t) {\r\n\t\t\t\tconst m =\r\n\t\t\t\t\t'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst lazyVNode = vnode.type();\r\n\t\t\t\t\twarnedComponents.lazyPropTypes.set(vnode.type, true);\r\n\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\tm + `Component wrapped in lazy() is ${getDisplayName(lazyVNode)}`\r\n\t\t\t\t\t);\r\n\t\t\t\t} catch (promise) {\r\n\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\tm + \"We will log the wrapped component's name once it is loaded.\"\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet values = vnode.props;\r\n\t\t\tif (vnode.type._forwarded) {\r\n\t\t\t\tvalues = assign({}, values);\r\n\t\t\t\tdelete values.ref;\r\n\t\t\t}\r\n\r\n\t\t\tcheckPropTypes(\r\n\t\t\t\tvnode.type.propTypes,\r\n\t\t\t\tvalues,\r\n\t\t\t\t'prop',\r\n\t\t\t\tgetDisplayName(vnode),\r\n\t\t\t\t() => getOwnerStack(vnode)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\r\n\t};\r\n\r\n\toptions._hook = (comp, index, type) => {\r\n\t\tif (!comp || !hooksAllowed) {\r\n\t\t\tthrow new Error('Hook can only be invoked from render methods.');\r\n\t\t}\r\n\r\n\t\tif (oldHook) oldHook(comp, index, type);\r\n\t};\r\n\r\n\t// Ideally we'd want to print a warning once per component, but we\r\n\t// don't have access to the vnode that triggered it here. As a\r\n\t// compromise and to avoid flooding the console with warnings we\r\n\t// print each deprecation warning only once.\r\n\tconst warn = (property, message) => ({\r\n\t\tget() {\r\n\t\t\tconst key = 'get' + property + message;\r\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\r\n\t\t\t\tdeprecations.push(key);\r\n\t\t\t\tconsole.warn(`getting vnode.${property} is deprecated, ${message}`);\r\n\t\t\t}\r\n\t\t},\r\n\t\tset() {\r\n\t\t\tconst key = 'set' + property + message;\r\n\t\t\tif (deprecations && deprecations.indexOf(key) < 0) {\r\n\t\t\t\tdeprecations.push(key);\r\n\t\t\t\tconsole.warn(`setting vnode.${property} is not allowed, ${message}`);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tconst deprecatedAttributes = {\r\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\r\n\t\tattributes: warn('attributes', 'use vnode.props'),\r\n\t\tchildren: warn('children', 'use vnode.props.children')\r\n\t};\r\n\r\n\tconst deprecatedProto = Object.create({}, deprecatedAttributes);\r\n\r\n\toptions.vnode = vnode => {\r\n\t\tconst props = vnode.props;\r\n\t\tif (\r\n\t\t\tvnode.type !== null &&\r\n\t\t\tprops != null &&\r\n\t\t\t('__source' in props || '__self' in props)\r\n\t\t) {\r\n\t\t\tconst newProps = (vnode.props = {});\r\n\t\t\tfor (let i in props) {\r\n\t\t\t\tconst v = props[i];\r\n\t\t\t\tif (i === '__source') vnode.__source = v;\r\n\t\t\t\telse if (i === '__self') vnode.__self = v;\r\n\t\t\t\telse newProps[i] = v;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// eslint-disable-next-line\r\n\t\tvnode.__proto__ = deprecatedProto;\r\n\t\tif (oldVnode) oldVnode(vnode);\r\n\t};\r\n\r\n\toptions.diffed = vnode => {\r\n\t\t// Check if the user passed plain objects as children. Note that we cannot\r\n\t\t// move this check into `options.vnode` because components can receive\r\n\t\t// children in any shape they want (e.g.\r\n\t\t// `<MyJSONFormatter>{{ foo: 123, bar: \"abc\" }}</MyJSONFormatter>`).\r\n\t\t// Putting this check in `options.diffed` ensures that\r\n\t\t// `vnode._children` is set and that we only validate the children\r\n\t\t// that were actually rendered.\r\n\t\tif (vnode._children) {\r\n\t\t\tvnode._children.forEach(child => {\r\n\t\t\t\tif (child && child.type === undefined) {\r\n\t\t\t\t\t// Remove internal vnode keys that will always be patched\r\n\t\t\t\t\tdelete child._parent;\r\n\t\t\t\t\tdelete child._depth;\r\n\t\t\t\t\tconst keys = Object.keys(child).join(',');\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Objects are not valid as a child. Encountered an object with the keys {${keys}}.` +\r\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thooksAllowed = false;\r\n\r\n\t\tif (oldDiffed) oldDiffed(vnode);\r\n\r\n\t\tif (vnode._children != null) {\r\n\t\t\tconst keys = [];\r\n\t\t\tfor (let i = 0; i < vnode._children.length; i++) {\r\n\t\t\t\tconst child = vnode._children[i];\r\n\t\t\t\tif (!child || child.key == null) continue;\r\n\r\n\t\t\t\tconst key = child.key;\r\n\t\t\t\tif (keys.indexOf(key) !== -1) {\r\n\t\t\t\t\tconsole.error(\r\n\t\t\t\t\t\t'Following component has two or more children with the ' +\r\n\t\t\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\r\n\t\t\t\t\t\t\t'in rendering process. Component: \\n\\n' +\r\n\t\t\t\t\t\t\tserializeVNode(vnode) +\r\n\t\t\t\t\t\t\t`\\n\\n${getOwnerStack(vnode)}`\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Break early to not spam the console\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkeys.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nconst setState = Component.prototype.setState;\r\nComponent.prototype.setState = function(update, callback) {\r\n\tif (this._vnode == null) {\r\n\t\t// `this._vnode` will be `null` during componentWillMount. But it\r\n\t\t// is perfectly valid to call `setState` during cWM. So we\r\n\t\t// need an additional check to verify that we are dealing with a\r\n\t\t// call inside constructor.\r\n\t\tif (this.state == null) {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t`Calling \"this.setState\" inside the constructor of a component is a ` +\r\n\t\t\t\t\t`no-op and might be a bug in your application. Instead, set ` +\r\n\t\t\t\t\t`\"this.state = {}\" directly.\\n\\n${getOwnerStack(getCurrentVNode())}`\r\n\t\t\t);\r\n\t\t}\r\n\t} else if (this._parentDom == null) {\r\n\t\tconsole.warn(\r\n\t\t\t`Can't call \"this.setState\" on an unmounted component. This is a no-op, ` +\r\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\r\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\r\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\r\n\t\t);\r\n\t}\r\n\r\n\treturn setState.call(this, update, callback);\r\n};\r\n\r\nconst forceUpdate = Component.prototype.forceUpdate;\r\nComponent.prototype.forceUpdate = function(callback) {\r\n\tif (this._vnode == null) {\r\n\t\tconsole.warn(\r\n\t\t\t`Calling \"this.forceUpdate\" inside the constructor of a component is a ` +\r\n\t\t\t\t`no-op and might be a bug in your application.\\n\\n${getOwnerStack(\r\n\t\t\t\t\tgetCurrentVNode()\r\n\t\t\t\t)}`\r\n\t\t);\r\n\t} else if (this._parentDom == null) {\r\n\t\tconsole.warn(\r\n\t\t\t`Can't call \"this.forceUpdate\" on an unmounted component. This is a no-op, ` +\r\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\r\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.` +\r\n\t\t\t\t`\\n\\n${getOwnerStack(this._vnode)}`\r\n\t\t);\r\n\t}\r\n\treturn forceUpdate.call(this, callback);\r\n};\r\n\r\n/**\r\n * Serialize a vnode tree to a string\r\n * @param {import('./internal').VNode} vnode\r\n * @returns {string}\r\n */\r\nexport function serializeVNode(vnode) {\r\n\tlet { props } = vnode;\r\n\tlet name = getDisplayName(vnode);\r\n\r\n\tlet attrs = '';\r\n\tfor (let prop in props) {\r\n\t\tif (props.hasOwnProperty(prop) && prop !== 'children') {\r\n\t\t\tlet value = props[prop];\r\n\r\n\t\t\t// If it is an object but doesn't have toString(), use Object.toString\r\n\t\t\tif (typeof value == 'function') {\r\n\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\r\n\t\t\t}\r\n\r\n\t\t\tvalue =\r\n\t\t\t\tObject(value) === value && !value.toString\r\n\t\t\t\t\t? Object.prototype.toString.call(value)\r\n\t\t\t\t\t: value + '';\r\n\r\n\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\r\n\t\t}\r\n\t}\r\n\r\n\tlet children = props.children;\r\n\treturn `<${name}${attrs}${\r\n\t\tchildren && children.length ? '>..</' + name + '>' : ' />'\r\n\t}`;\r\n}\r\n", "export const ELEMENT_NODE = 1;\r\nexport const DOCUMENT_NODE = 9;\r\nexport const DOCUMENT_FRAGMENT_NODE = 11;\r\n", "/**\r\n * Assign properties from `props` to `obj`\r\n * @template O, P The obj and props types\r\n * @param {O} obj The object to copy properties to\r\n * @param {P} props The object to copy properties from\r\n * @returns {O & P}\r\n */\r\nexport function assign(obj, props) {\r\n\tfor (let i in props) obj[i] = props[i];\r\n\treturn /** @type {O & P} */ (obj);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
